package website

import (
	"bytes"
	"fmt"
	"go/format"
	"io/ioutil"
	"log"
	"os"
	"path/filepath"
	"unicode"
)

//go:generate go run makestatic.go

var files = []string{}

// Generate reads a set of files and returns a file buffer that declares
// a map of string constants containing contents of the input files.
func Generate() ([]byte, error) {

	buf := new(bytes.Buffer)

	fmt.Fprintf(buf, "%v\n\n%v\n\npackage website\n\n", license, warning)
	fmt.Fprintf(buf, "var Files = map[string]string{\n")

	err := filepath.Walk("build", func(path string, f os.FileInfo, err error) error {
		if err != nil {
			return nil
		}

		if !f.IsDir() {
			b, err := ioutil.ReadFile(path)
			if err != nil {
				return err
			}
			fmt.Fprintf(buf, "\t%q: ", f.Name())
			appendQuote(buf, b)
			fmt.Fprintf(buf, ",\n\n")
		}

		return nil
	})

	if err != nil {
		log.Printf("Error while walking path %s: %s", "./build", err)
	}

	fmt.Fprintln(buf, "}")

	return format.Source(buf.Bytes())
}

// appendQuote is like strconv.AppendQuote, but we avoid the latter
// because it changes when Unicode evolves, breaking gen_test.go.
func appendQuote(out *bytes.Buffer, data []byte) {
	out.WriteByte('"')
	for _, b := range data {
		if b == '\\' || b == '"' {
			out.WriteByte('\\')
			out.WriteByte(b)
		} else if b <= unicode.MaxASCII && unicode.IsPrint(rune(b)) && !unicode.IsSpace(rune(b)) {
			out.WriteByte(b)
		} else {
			fmt.Fprintf(out, "\\x%02x", b)
		}
	}
	out.WriteByte('"')
}

const warning = `// Code generated by "makestatic"; DO NOT EDIT.`

const license = `// Copyright Rapde/Rap. All rights reserved.
// Use of this source code is governed by a BSD-2-Clause License
// license that can be found in the LICENSE file.`
